## 1.0 项目总结与后续开发规划

### 1.1 微信小程序登录流程总结

我们最终实现的，是一个**安全、健壮且符合官方规范**的登录流程。它的每一步都至关重要：

1. **前端 - 用户首次点击登录 (`handleLogin`)**
   - **获取临时凭证**: 调用 `uni.login()` 与微信服务器通信，获取一次性的 `code`。
   - **静默登录/注册**: 将 `code` 发送给我们云端的 `uni-id-co` 云对象中的 `loginByWeixin` 方法。
   - **云端 - `loginByWeixin`**
     - 拿着 `code` 和我们在 `config.json` 里配置的 `appSecret`，向微信服务器换取用户的 `openid`。
     - 检查 `uni-id-users` 表，看这个 `openid` 是否已存在。
       - **是 (老用户)**: 直接登录。
       - **否 (新用户)**: 在 `uni-id-users` 表中创建一个新用户记录。
     - **执行 `beforeRegister` 钩子**: 在新用户数据入库前，我们的钩子函数强制为该用户添加了 `role: ["member"]` 字段。
     - **生成并返回 Token**: 为用户生成一个包含其 `uid` 和**空角色**的 Token（权限滞后问题根源），并返回给前端。
   - **前端 - 存储凭证**: 前端接收到 `uid` 和 `token`，并将它们分别存入本地缓存。
   - **前端 - 检查用户信息**: 紧接着，调用 `getAccountInfo` 检查用户信息是否完整。
   - **前端 - 状态切换**: 发现 `isNicknameSet: false`，于是更新UI，将按钮变为“授权头像昵称以继续”。
2. **前端 - 用户二次点击授权 (`handleGetUserProfile`)**
   - **触发授权**: 调用 `uni.getUserProfile()`，**由用户点击直接触发**，符合微信规范，弹出授权窗口。
   - **获取用户信息**: 用户同意后，获取到临时的 `nickName` 和 `avatarUrl`。
   - **更新数据库 (`updateUserApi`)**: 调用我们**最终使用**的 `clientDB` 方案。
   - **云端 - `clientDB` 操作**
     - `clientDB` 会自动携带用户的**新 Token**（`uni-id` 框架在调用 `getAccountInfo` 后可能已内部刷新）或旧 `token` 发起请求。
     - uniCloud云数据库接收到更新 `uni-id-users` 表的请求。
     - **触发 Schema 校验**: 数据库会加载 `uni-id-users.schema.json` 文件，并用其中的 `"update": "doc._id == auth.uid"` 规则进行校验。
     - **校验通过**: `token` 解码后的 `uid` 与要更新的文档 `_id` 一致，权限校验成功，数据成功写入。
   - **前端 - 流程完成**: 更新本地 `store` 中的用户信息，并跳转到学生中心。

### 1.2 数据库 `schema.json` 的工作机制解析

您可以把 `schema.json` 文件想象成**云数据库门口的“智能安保系统”**，它负责三件大事：

1. **定义数据结构 (`properties`)**:
   - 它规定了每一张表（如 `uni-id-users`）应该有哪些字段（`nickname`, `avatar` 等）。
   - 它还定义了每个字段的**数据类型**（`bsonType`: "string"）、**默认值**（`defaultValue`: 0）、**合法格式**（`format`: "email"）等。
   - 如果前端传来一个不符合结构的数据（比如 `gender` 传了一个字符串"男"而不是数字1），这个安保系统会直接拒绝写入，保证了数据的规整性。
2. **设置权限规则 (`permission`)**:
   - 这是 `schema.json` 最核心的功能。它定义了在**什么条件下**，才允许对数据进行**增 (`create`)、删 (`delete`)、改 (`update`)、查 (`read`)** 操作。
   - 它的规则是基于**表达式**的，非常灵活。例如：
     - `"read": true`: 任何人都可以读取。
     - `"update": "doc._id == auth.uid"`: **只有当**要修改的文档ID (`doc._id`) **等于** 当前登录用户的ID (`auth.uid`) 时，才允许修改。这正是我们最终成功的关键。
     - `"delete": "'admin' in auth.role"`: **只有当** “admin” 这个角色字符串存在于当前用户的角色列表 (`auth.role`) 中时，才允许删除。
   - **`clientDB` 操作会严格遵守这套规则**，这就是为什么我们最终改用 `clientDB` 后，问题迎刃而解。
3. **关联外键 (`foreignKey`)**:
   - 它可以定义一个字段（如 `role`）的值，必须是另一张表（`uni-id-roles`）中某个字段（`role_id`）的已有值，从而保证了数据间的关联性和一致性。

**总结**: `schema.json` 是 uniCloud 数据库的灵魂，它将数据结构、权限控制和业务规则集于一身，是保障您应用安全、稳定、可控的核心基石。

### 1.3 如何增加新角色并设计分配流程

好的，现在我们进入激动人心的业务设计环节！

#### **1.3.1 增加新角色 (学生、老师、校长、管理员)**

我们将采用之前用过的、最专业的**自动化初始化**方案。

1. **修改 `db_init.json` 文件**

   - 打开 `uniCloud/database/db_init.json` 文件。
   - 用下面这份**包含了所有新角色和新权限**的代码**完全替换**原有内容。

   ```
   {
     "uni-id-permissions": {
       "data": [
         { "_id": "update_user_info_permission", "permission_id": "UPDATE_UNI_ID_USERS", "permission_name": "更新用户信息" },
         { "_id": "submit_homework_permission", "permission_id": "SUBMIT_HOMEWORK", "permission_name": "提交作业" },
         { "_id": "evaluate_homework_permission", "permission_id": "EVALUATE_HOMEWORK", "permission_name": "评价作业" },
         { "_id": "assign_teacher_permission", "permission_id": "ASSIGN_TEACHER", "permission_name": "分配老师" },
         { "_id": "manage_school_permission", "permission_id": "MANAGE_SCHOOL", "permission_name": "学校管理" }
       ]
     },
     "uni-id-roles": {
       "data": [
         { "_id": "student_role", "role_id": "student", "role_name": "学生", "permission": ["SUBMIT_HOMEWORK", "UPDATE_UNI_ID_USERS"] },
         { "_id": "teacher_role", "role_id": "teacher", "role_name": "老师", "permission": ["EVALUATE_HOMEWORK"] },
         { "_id": "principal_role", "role_id": "principal", "role_name": "校长", "permission": ["ASSIGN_TEACHER"] },
         { "_id": "admin_role", "role_id": "admin", "role_name": "超级管理员", "permission": ["MANAGE_SCHOOL"] }
       ]
     }
   }
   ```

   **设计解析**:

   - 我们定义了更细化的权限，如“提交作业”、“评价作业”等。
   - **学生**: 拥有“提交作业”和“更新自己信息”的权限。
   - **老师**: 拥有“评价作业”的权限。
   - **校长**: 拥有“分配老师”的权限。
   - **管理员**: 拥有最高的“学校管理”权限。

2. **重新初始化数据库**

   - 在 `db_init.json` 文件上**右键** -> **“初始化云数据库”**，并**勾选“清除云数据库已有数据”**。

#### **1.3.2 设计学生注册流程**

我们将扩展用户表，并改造注册流程，让学生可以选择学校。

1. **扩展用户表 Schema**

   - 打开 `uniCloud/database/uni-id-users.schema.json`。
   - 在 `"properties"` 节点内，添加两个新字段 `school_id` 和 `teacher_ids`。

   ```
   // ... "properties" 节点内 ...
   "role": { ... }, // 已有字段
   "school_id": {
     "bsonType": "string",
     "description": "所属学校ID",
     "foreignKey": "schools._id" // 假设我们有一张 schools 表
   },
   "teacher_ids": {
     "bsonType": "array",
     "description": "所属老师ID列表",
     "foreignKey": "uni-id-users._id"
   },
   "tags": { ... } // 已有字段
   // ...
   ```

   - **创建 `schools` 表**: 右键 `database` 目录 -> “新建Schema及DB Collection”，创建一个名为 `schools` 的表，用于存放学校信息。
   - 上传这两个新的/修改过的 Schema 文件。

2. **改造注册/登录页面**

   - 在 `pages/login.vue` 中，当 `loginState` 变为 `'profileRequired'` 时，除了显示“授权头像昵称”按钮，还需要显示一个**学校选择器**（picker 组件）。
   - 学生选择学校后，我们将 `school_id` 暂存起来。

3. **改造 `updateUserApi`**

   - 在 `handleGetUserProfile` 方法中，调用 `updateUserApi` 时，将 `school_id` 也一并传过去。
   - `clientDB` 会自动将 `school_id` 写入用户的数据库记录中。

#### **1.3.3 设计校长为学生分配老师流程**

这将是一个典型的后台管理功能。

1. **创建校长管理页面**
   - 创建一个新的页面，例如 `pages/principal/assign.vue`。
   - 这个页面需要做**路由守卫**：在页面加载时，检查当前登录用户的角色是否包含 `'principal'`，如果不包含，则提示无权限并返回。
2. **页面功能设计**
   - **获取本校学生列表**: 校长在该页面中，可以调用一个新的云对象方法 `principal-service.getStudents()`，该方法会返回所有 `school_id` 与校长所在学校ID一致、且尚未分配老师的学生列表。
   - **获取本校老师列表**: 调用 `principal-service.getTeachers()` 获取老师列表。
   - **分配操作**: 校长为每个学生勾选一位或多位老师，点击“确认分配”。
   - **调用分配接口**: 前端将“学生ID”和“勾选的老师ID列表”作为参数，调用 `principal-service.assignTeachers(studentId, teacherIds)`。
3. **创建 `principal-service` 云对象**
   - 这个云对象中的 `assignTeachers` 方法会执行以下操作：
     - **权限校验**: 检查调用者是否是校长。
     - **数据库更新**: 使用 `db.collection('uni-id-users').doc(studentId).update({ teacher_ids: teacherIds })`，将老师ID更新到学生的记录中。

至此，您不仅拥有了一个稳固的登录系统，还为未来的多角色、多权限业务流程规划好了清晰、可扩展的开发蓝图。